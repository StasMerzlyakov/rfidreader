// Dev is an handle to an MFRC522 RFID reader.
// Rewrite periph.io/x/periph/experimental/devices/mfrc522
// based on git@github.com:paguz/RPi-RFID.git
package mfrc522

import (
	"bytes"
	"errors"
	_ "log"
	"time"

	"periph.io/x/periph/conn/gpio"
	_ "periph.io/x/periph/conn/gpio/gpioreg"
	"periph.io/x/periph/conn/physic"
	"periph.io/x/periph/conn/spi"
)

var MFRC522_VER_1_0 = []byte{0x00, 0xC6, 0x37, 0xD5, 0x32, 0xB7, 0x57, 0x5C,
	0xC2, 0xD8, 0x7C, 0x4D, 0xD9, 0x70, 0xC7, 0x73,
	0x10, 0xE6, 0xD2, 0xAA, 0x5E, 0xA1, 0x3E, 0x5A,
	0x14, 0xAF, 0x30, 0x61, 0xC9, 0x70, 0xDB, 0x2E,
	0x64, 0x22, 0x72, 0xB5, 0xBD, 0x65, 0xF4, 0xEC,
	0x22, 0xBC, 0xD3, 0x72, 0x35, 0xCD, 0xAA, 0x41,
	0x1F, 0xA7, 0xF3, 0x53, 0x14, 0xDE, 0x7E, 0x02,
	0xD9, 0x0F, 0xB5, 0x5E, 0x25, 0x1D, 0x29, 0x79}

var MFRC522_VER_2_0 = []byte{0x00, 0xEB, 0x66, 0xBA, 0x57, 0xBF, 0x23, 0x95,
	0xD0, 0xE3, 0x0D, 0x3D, 0x27, 0x89, 0x5C, 0xDE,
	0x9D, 0x3B, 0xA7, 0x00, 0x21, 0x5B, 0x89, 0x82,
	0x51, 0x3A, 0xEB, 0x02, 0x0C, 0xA5, 0x00, 0x49,
	0x7C, 0x84, 0x4D, 0xB3, 0xCC, 0xD2, 0x1B, 0x81,
	0x5D, 0x48, 0x76, 0xD5, 0x71, 0x61, 0x21, 0xA9,
	0x86, 0x96, 0x83, 0x38, 0xCF, 0x9D, 0x5B, 0x6D,
	0xDC, 0x15, 0xBA, 0x3E, 0x7D, 0x95, 0x3B, 0x2F}

const (
	// MFRC522 v1
	VER_1_0 = 0x91
	// MFRC522 v2
	VER_2_0 = 0x92

	// Page 0: Command and status
	//						  0x00	// reserved for future use
	CommandReg    = 0x01 // starts and stops command execution
	ComIEnReg     = 0x02 // enable and disable interrupt request control bits
	DivIEnReg     = 0x03 // enable and disable interrupt request control bits
	ComIrqReg     = 0x04 // interrupt request bits
	DivIrqReg     = 0x05 // interrupt request bits
	ErrorReg      = 0x06 // error bits showing the error status of the last command executed
	Status1Reg    = 0x07 // communication status bits
	Status2Reg    = 0x08 // receiver and transmitter status bits
	FIFODataReg   = 0x09 // input and output of 64 byte FIFO buffer
	FIFOLevelReg  = 0x0A // number of bytes stored in the FIFO buffer
	WaterLevelReg = 0x0B // level for FIFO underflow and overflow warning
	ControlReg    = 0x0C // miscellaneous control registers
	BitFramingReg = 0x0D // adjustments for bit-oriented frames
	CollReg       = 0x0E // bit position of the first bit-collision detected on the RF interface
	//						  0x0F		// reserved for future use

	// Page 1: Command
	// 						  0x10	// reserved for future use
	ModeReg        = 0x11 // defines general modes for transmitting and receiving
	TxModeReg      = 0x12 // defines transmission data rate and framing
	RxModeReg      = 0x13 // defines reception data rate and framing
	TxControlReg   = 0x14 // controls the logical behavior of the antenna driver pins TX1 and TX2
	TxASKReg       = 0x15 // controls the setting of the transmission modulation
	TxSelReg       = 0x16 // selects the internal sources for the antenna driver
	RxSelReg       = 0x17 // selects internal receiver settings
	RxThresholdReg = 0x18 // selects thresholds for the bit decoder
	DemodReg       = 0x19 // defines demodulator settings
	// 						  0x1A	// reserved for future use
	// 						  0x1B	// reserved for future use
	MfTxReg = 0x1C // controls some MIFARE communication transmit parameters
	MfRxReg = 0x1D // controls some MIFARE communication receive parameters
	// 						  0x1E	// reserved for future use
	SerialSpeedReg = 0x1F // selects the speed of the serial UART interface

	// Page 2: Configuration
	// 						  0x20	// reserved for future use
	CRCResultRegH = 0x21 // shows the MSB and LSB values of the CRC calculation
	CRCResultRegL = 0x22
	// 						  0x23	// reserved for future use
	ModWidthReg = 0x24 // controls the ModWidth setting?
	// 						  0x25	// reserved for future use
	RFCfgReg          = 0x26 // configures the receiver gain
	GsNReg            = 0x27 // selects the conductance of the antenna driver pins TX1 and TX2 for modulation
	CWGsPReg          = 0x28 // defines the conductance of the p-driver output during periods of no modulation
	ModGsPReg         = 0x29 // defines the conductance of the p-driver output during periods of modulation
	TModeReg          = 0x2A // defines settings for the internal timer
	TPrescalerReg     = 0x2B // the lower 8 bits of the TPrescaler value. The 4 high bits are in TModeReg.
	TReloadRegH       = 0x2C // defines the 16-bit timer reload value
	TReloadRegL       = 0x2D
	TCounterValueRegH = 0x2E // shows the 16-bit timer value
	TCounterValueRegL = 0x2F

	// Page 3: Test Registers
	// 						  0x30			// reserved for future use
	TestSel1Reg     = 0x31 // general test signal configuration
	TestSel2Reg     = 0x32 // general test signal configuration
	TestPinEnReg    = 0x33 // enables pin output driver on pins D1 to D7
	TestPinValueReg = 0x34 // defines the values for D1 to D7 when it is used as an I/O bus
	TestBusReg      = 0x35 // shows the status of the internal test bus
	AutoTestReg     = 0x36 // controls the digital self test
	VersionReg      = 0x37 // shows the software version
	AnalogTestReg   = 0x38 // controls the pins AUX1 and AUX2
	TestDAC1Reg     = 0x39 // defines the test value for TestDAC1
	TestDAC2Reg     = 0x3A // defines the test value for TestDAC2
	TestADCReg      = 0x3B // shows the value of ADC I and Q channels
	// 						  0x3C			// reserved for production tests
	// 						  0x3D			// reserved for production tests
	// 						  0x3E			// reserved for production tests
	// 						  0x3F			// reserved for production tests

	PCD_Idle             = 0x00 // no action, cancels current command execution
	PCD_Mem              = 0x01 // stores 25 bytes into the internal buffer
	PCD_GenerateRandomID = 0x02 // generates a 10-byte random ID number
	PCD_CalcCRC          = 0x03 // activates the CRC coprocessor or performs a self test
	PCD_Transmit         = 0x04 // transmits data from the FIFO buffer
	PCD_NoCmdChange      = 0x07 // no command change, can be used to modify the CommandReg register bits without affecting the command, for example, the PowerDown bit
	PCD_Receive          = 0x08 // activates the receiver circuits
	PCD_Transceive       = 0x0C // transmits data from FIFO buffer to antenna and automatically activates the receiver after transmission
	PCD_MFAuthent        = 0x0E // performs the MIFARE standard authentication as a reader
	PCD_SoftReset        = 0x0F // resets the MFRC522

	PICC_CMD_REQA = 0x26 // REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame.
	PICC_CMD_WUPA = 0x52 // Wake-UP command, Type A. Invites PICCs in state IDLE and HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame.

	STATUS_OK             = 1 // Success
	STATUS_ERROR          = 2 // Error in communication
	STATUS_COLLISION      = 3 // Collission detected
	STATUS_TIMEOUT        = 4 // Timeout in communication.
	STATUS_NO_ROOM        = 5 // A buffer is not big enough.
	STATUS_INTERNAL_ERROR = 6 // Internal error in the code. Should not happen ;-)
	STATUS_INVALID        = 7 // Invalid argument.
	STATUS_CRC_WRONG      = 8 // The CRC_A does not match
	STATUS_MIFARE_NACK    = 9 // A MIFARE PICC responded with NAK.

)

type MFRC522 struct {
	spiDev spi.Conn
	//operationTimeout time.Duration
	//	beforeCall       func()
	//afterCall        func()
	resetPin gpio.PinOut
	irqPin   gpio.PinIn
	//antennaGain int
}

func NewMFRC522(spiPort spi.Port, resetPin gpio.PinOut, irqPin gpio.PinIn) (*MFRC522, error) {
	spiDev, err := spiPort.Connect(10*physic.MegaHertz, spi.Mode0, 8)
	if err != nil {
		return nil, err
	}
	mfrc := &MFRC522{
		spiDev:   spiDev,
		resetPin: resetPin,
		irqPin:   irqPin,
	}
	return mfrc, nil
}

/////////////////////////////////////////////////////////////////////////////////////
// Basic interface functions for communicating with the MFRC522
/////////////////////////////////////////////////////////////////////////////////////

/**
 * Writes a byte to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
func (r *MFRC522) PCD_WriteRegister(address, value byte) error {
	newData := []byte{(byte(address) << 1) & 0x7E, value}
	err := r.spiDev.Tx(newData, nil)
	return err
}

/**
 * Writes a number of bytes to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
func (r *MFRC522) PCD_WriteRegisterArr(address byte, value []byte) error {
	for _, val := range value {
		if err := r.PCD_WriteRegister(address, val); err != nil {
			return err
		}
	}
	return nil
}

/**
 * Reads a number of bytes from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
func (r *MFRC522) PCD_ReadRegister(address byte) (byte, error) {
	data := []byte{((byte(address) << 1) & 0x7E) | 0x80, 0}
	out := make([]byte, len(data))
	if err := r.spiDev.Tx(data, out); err != nil {
		return 0, err
	}
	return out[1], nil
}

/**
 * Reads a number of bytes from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */

func (r *MFRC522) PCD_ReadRegisterArr(address byte, count int) ([]byte, error) {
	result := make([]byte, count)
	for ind := range result {
		if val, err := r.PCD_ReadRegister(address); err != nil {
			return nil, err
		} else {
			result[ind] = val
		}
	}
	return result, nil
}

/**
 * Clears the bits given in mask from register reg.
 */
func (r *MFRC522) PCD_ClearRegisterBitMask(reg, mask byte) error {
	if current, err := r.PCD_ReadRegister(reg); err != nil {
		return err
	} else {
		return r.PCD_WriteRegister(reg, current&^mask) // clear bit mask
	}
} // End PCD_ClearRegisterBitMask()

/**
 * Sets the bits given in mask in register reg.
 */
func (r *MFRC522) PCD_SetRegisterBitMask(reg, mask byte) error {
	if tmp, err := r.PCD_ReadRegister(reg); err != nil {
		return err
	} else {
		return r.PCD_WriteRegister(reg, tmp|mask) // set bit mask
	}

} // End PCD_SetRegisterBitMask()

/**
 * Use the CRC coprocessor in the MFRC522 to calculate a CRC_A.
 * @param data < The data to transfer to the FIFO for CRC calculation.
 * @return Result is written to result[0..1], low byte first.
 */
func (r *MFRC522) PCD_CalculateCRC(data []byte) ([]byte, error) {
	err := r.PCD_WriteRegister(CommandReg, PCD_Idle) // Stop any active command.
	if err != nil {
		return nil, err
	}
	err = r.PCD_WriteRegister(DivIrqReg, 0x04) // Clear the CRCIRq interrupt request bit
	if err != nil {
		return nil, err
	}
	err = r.PCD_SetRegisterBitMask(FIFOLevelReg, 0x80) // FlushBuffer = 1, FIFO initialization
	if err != nil {
		return nil, err
	}
	err = r.PCD_WriteRegisterArr(FIFODataReg, data) // Write data to the FIFO
	if err != nil {
		return nil, err
	}
	err = r.PCD_WriteRegister(CommandReg, PCD_CalcCRC) // Start the calculation
	if err != nil {
		return nil, err
	}
	// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73ms.
	i := 5000
	for {
		if n, err := r.PCD_ReadRegister(DivIrqReg); err != nil { // DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq reserved CRCIRq reserved reserved
			return nil, err
		} else {
			if n&0x04 > 0 { // CRCIRq bit set - calculation done
				break
			}
		}
		i = i - 1

		if i == 0 { // The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.
			return nil, errors.New("Communication with the MFRC522 might be down")
		}
	}
	err = r.PCD_WriteRegister(CommandReg, PCD_Idle) // Stop calculating CRC for new content in the FIFO.
	if err != nil {
		return nil, err
	}
	// Transfer the result from the registers to the result buffer
	result := make([]byte, 2)
	result[0], err = r.PCD_ReadRegister(CRCResultRegL)
	if err != nil {
		return nil, err
	}
	result[1], err = r.PCD_ReadRegister(CRCResultRegH)
	if err != nil {
		return nil, err
	}
	return result, nil
} // End PCD_CalculateCRC()

/////////////////////////////////////////////////////////////////////////////////////
// Functions for manipulating the MFRC522
/////////////////////////////////////////////////////////////////////////////////////

/**
 * Performs a soft reset on the MFRC522 chip and waits for it to be ready again.
 */
func (r *MFRC522) PCD_Reset() error {
	r.PCD_WriteRegister(CommandReg, PCD_SoftReset)

	// Wait for the PowerDown bit in CommandReg to be cleared
	for i := 0; i < 3; i++ {
		// Section 8.8.2 in the datasheet says the oscillator start-up time is the
		// start up time of the crystal + 37,74ms. Let us be generous: 50ms.
		time.Sleep(50)
		if val, err := r.PCD_ReadRegister(CommandReg); err != nil {
			return err
		} else {
			if val&(1<<4) == 0 {
				return nil
			}
		}

	}
	return errors.New("PowerDown bit not cleared")
} // End PCD_Reset()

/**
 * Turns the antenna on by enabling pins TX1 and TX2.
 * After a reset these pins are disabled.
 */
func (r *MFRC522) PCD_AntennaOn() error {
	value, err := r.PCD_ReadRegister(TxControlReg)
	if err != nil {
		return err
	}
	if (value & 0x03) != 0x03 {
		err = r.PCD_WriteRegister(TxControlReg, value|0x03)
		if err != nil {
			return err
		}
	}
	return nil
} // End PCD_AntennaOn()

/**
 * Turns the antenna off by disabling pins TX1 and TX2.
 */
func (r *MFRC522) PCD_AntennaOff() error {
	return r.PCD_ClearRegisterBitMask(TxControlReg, 0x03)
} // End PCD_AntennaOff()

/**
 * Initializes the MFRC522 chip.
 */
func (r *MFRC522) PCD_Init() {
	r.PCD_Reset()

	// When communicating with a PICC we need a timeout if something goes wrong.
	// f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].
	// TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.
	r.PCD_WriteRegister(TModeReg, 0x80)      // TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
	r.PCD_WriteRegister(TPrescalerReg, 0xA9) // TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25ï¿½s.
	r.PCD_WriteRegister(TReloadRegH, 0x03)   // Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
	r.PCD_WriteRegister(TReloadRegL, 0xE8)

	r.PCD_WriteRegister(TxASKReg, 0x40) // Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
	r.PCD_WriteRegister(ModeReg, 0x3D)  // Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
	r.PCD_AntennaOn()                   // Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
} // End PCD_Init()

/**
 * Get the current MFRC522 Receiver Gain (RxGain[2:0]) value.
 * See 9.3.3.6 / table 98 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
 * NOTE: Return value scrubbed with (0x07<<4)=01110000b as RCFfgReg may use reserved bits.
 *
 * @return Value of the RxGain, scrubbed to the 3 bits used.
 */
func (r *MFRC522) PCD_GetAntennaGain() (byte, error) {
	val, err := r.PCD_ReadRegister(RFCfgReg)
	if err != nil {
		return 0, err
	}
	return val & (0x07 << 4), nil
} // End PCD_GetAntennaGain()

/**
 * Set the MFRC522 Receiver Gain (RxGain) to value specified by given mask.
 * See 9.3.3.6 / table 98 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
 * NOTE: Given mask is scrubbed with (0x07<<4)=01110000b as RCFfgReg may use reserved bits.
 */
func (r *MFRC522) PCD_SetAntennaGain(mask byte) error {
	if val, err := r.PCD_GetAntennaGain(); err != nil {
		return err
	} else {
		if val != mask {
			// only bother if there is a change
			// clear needed to allow 000 pattern
			if er := r.PCD_ClearRegisterBitMask(RFCfgReg, (0x07 << 4)); er != nil {
				return er
			}
			if er := r.PCD_SetRegisterBitMask(RFCfgReg, mask&(0x07<<4)); er != nil {
				return er
			} // only set RxGain[2:0] bits
		}
	}
	return nil
} // End PCD_SetAntennaGain()

/**
 * Performs a self-test of the MFRC522
 * See 16.1.1 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
 *
 * @return Whether or not the test passed.
 */
func (r *MFRC522) PCD_PerformSelfTest() error {
	// This follows directly the steps outlined in 16.1.1
	// 1. Perform a soft reset.

	if err := r.PCD_Reset(); err != nil {
		return err
	}

	// 2. Clear the internal buffer by writing 25 bytes of 00h
	ZEROES := make([]byte, 25)
	if err := r.PCD_SetRegisterBitMask(FIFOLevelReg, 0x80); err != nil { // flush the FIFO buffer
		return err
	}
	if err := r.PCD_WriteRegisterArr(FIFODataReg, ZEROES); err != nil { // write 25 bytes of 00h to FIFO
		return err
	}
	if err := r.PCD_WriteRegister(CommandReg, PCD_Mem); err != nil { // transfer to internal buffer
		return err
	}
	// 3. Enable self-test
	if err := r.PCD_WriteRegister(AutoTestReg, 0x09); err != nil {
		return err
	}

	// 4. Write 00h to FIFO buffer
	if err := r.PCD_WriteRegister(FIFODataReg, 0x00); err != nil {
		return err
	}

	// 5. Start self-test by issuing the CalcCRC command
	if err := r.PCD_WriteRegister(CommandReg, PCD_CalcCRC); err != nil {
		return err
	}

	// 6. Wait for self-test to complete
	i := 0
	for i := 0; i < 0xFF; i++ {
		if n, err := r.PCD_ReadRegister(DivIrqReg); err != nil { // DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq reserved CRCIRq reserved reserved
			return err
		} else {
			if n&0x04 > 0 { // CRCIRq bit set - calculation done
				break
			}
		}
	}
	if i == 0xFF {
		return errors.New("MFRC522 self test error")
	}

	if err := r.PCD_WriteRegister(CommandReg, PCD_Idle); err != nil { // Stop calculating CRC for new content in the FIFO.
		return err
	}
	// 7. Read out resulting 64 bytes from the FIFO buffer.
	result, err := r.PCD_ReadRegisterArr(FIFODataReg, 64)
	if err != nil {
		return err
	}

	// Auto self-test done
	// Reset AutoTestReg register to be 0 again. Required for normal operation.
	if err := r.PCD_WriteRegister(AutoTestReg, 0x00); err != nil {
		return err
	}

	// Determine firmware version (see section 9.3.4.8 in spec)
	version, err := r.PCD_ReadRegister(VersionReg)
	if err != nil {
		return err
	}
	var expected []byte
	switch version {
	case VER_1_0:
		expected = MFRC522_VER_1_0
	case VER_2_0:
		expected = MFRC522_VER_2_0
	}

	if bytes.Compare(result, expected) != 0 {
		return errors.New("MFRC522 Self test [ERROR]")
	}
	return nil
} // End PCD_PerformSelfTest()

/////////////////////////////////////////////////////////////////////////////////////
// Functions for communicating with PICCs
/////////////////////////////////////////////////////////////////////////////////////

func (r *MFRC522) PCD_TransceiveData(
	sendData []byte, /* The data to transfer to the FIFO. */
	validBitsIn byte, /* The number of valid bits in the last byte. 0 for 8 valid bits. */
	rxAlign byte, /* Defines the bit position in backData[0] for the first bit received. Default 0. */
	checkCRC bool, /* True => The last two bytes of the response is assumed to be a CRC_A that must be validated. */
	getData bool, /* True => The caller wants data back */
) (backData []byte, /* nil or buffer if data should be read back after executing the command. */
	validBitsOut byte, /* The number of valid bits in the last byte. 0 for 8 valid bits. */
	err error) {
	waitIRq := byte(0x30) // RxIRq and IdleIRq
	return r.PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, validBitsIn, rxAlign, checkCRC, getData)

}

/**
 * Transfers data to the MFRC522 FIFO, executes a command, waits for completion and transfers
 * data  back from the FIFO.
 * CRC validation can only be done if backData and backLen are specified.
 */
func (r *MFRC522) PCD_CommunicateWithPICC(
	command byte, /* The command to execute. One of the PCD_XXX constants  */
	waitIRq byte, /* The bits in the ComIrqReg register that signals successful completion of the command. */
	sendData []byte, /* The data to transfer to the FIFO. */
	validBitsIn byte, /* The number of valid bits in the last byte. 0 for 8 valid bits. */
	rxAlign byte, /* Defines the bit position in backData[0] for the first bit received. Default 0. */
	checkCRC bool, /* True => The last two bytes of the response is assumed to be a CRC_A that must be validated. */
	getData bool, /* True => The caller wants data back */
) (backData []byte, /* nil or buffer if data should be read back after executing the command. */
	validBitsOut byte, /* The number of valid bits in the last byte. 0 for 8 valid bits. */
	err error) {

	// Prepare values for BitFramingReg
	bitFraming := (rxAlign << 4) + validBitsIn // RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]

	// Stop any active command.
	if err := r.PCD_WriteRegister(CommandReg, PCD_Idle); err != nil {
		return nil, 0, err
	}

	// Clear all seven interrupt request bits
	if err := r.PCD_WriteRegister(ComIrqReg, 0x7F); err != nil {
		return nil, 0, err
	}

	// FlushBuffer = 1, FIFO initialization
	if err := r.PCD_SetRegisterBitMask(FIFOLevelReg, 0x80); err != nil {
		return nil, 0, err
	}

	// Write sendData to the FIFO
	if err := r.PCD_WriteRegisterArr(FIFODataReg, sendData); err != nil {
		return nil, 0, err
	}

	// Bit adjustments
	if err := r.PCD_WriteRegister(BitFramingReg, bitFraming); err != nil {
		return nil, 0, err
	}

	// Execute the command
	if err := r.PCD_WriteRegister(CommandReg, command); err != nil {
		return nil, 0, err
	}
	if command == PCD_Transceive {
		// StartSend=1, transmission of data starts
		if err := r.PCD_SetRegisterBitMask(BitFramingReg, 0x80); err != nil {
			return nil, 0, err
		}
	}

	// Wait for the command to complete.
	// In PCD_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the PCD stops transmitting.
	// Each iteration of the do-while-loop takes 17.86 ms.
	i := 2000
	for {
		if n, err := r.PCD_ReadRegister(ComIrqReg); err != nil { // ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq HiAlertIRq LoAlertIRq ErrIRq TimerIRq
			return nil, 0, err
		} else {
			if n&waitIRq > 0 { // One of the interrupts that signal success has been set.
				break
			}
			if n&0x01 > 0 { // Timer interrupt - nothing received in 25ms
				return nil, 0, errors.New("Timer interrupt - nothing received in 25ms")
			}
		}
		i = i - 1

		if i == 0 { // The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.
			return nil, 0, errors.New("The emergency break. If all other condions fail we will eventually terminate on this one after 35.7ms. Communication with the MFRC522 might be down.")
		}
	}

	// Stop now if any errors except collisions were detected.
	if errorRegValue, err := r.PCD_ReadRegister(ErrorReg); err != nil { // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl CollErr CRCErr ParityErr ProtocolErr
		return nil, 0, err
	} else {
		if errorRegValue&0x13 > 0 { // BufferOvfl ParityErr ProtocolErr
			return nil, 0, errors.New("BufferOvfl ParityErr ProtocolErr")
		}
	}

	// If the caller wants data back, get it from the MFRC522.
	if getData {
		if n, err := r.PCD_ReadRegister(FIFOLevelReg); err != nil { // Number of bytes in the FIFO
			return nil, 0, err
		} else {
			// Get N bytes returned
			if backData, err = r.PCD_ReadRegisterArr(FIFODataReg, int(n)); err != nil {
				return nil, 0, err
			} else {
				if validBitsIn != 0 {
					validBitsOut, err = r.PCD_ReadRegister(ControlReg)
					if err != nil {
						return nil, 0, err
					}
					validBitsOut = validBitsOut & 0x07
				}
			}
		}
		// Perform CRC_A validation if requested.
		if checkCRC {
			if len(backData) == 1 && validBitsOut == 4 {
				return nil, 0, errors.New("In this case a MIFARE Classic NAK is not OK.")
			}

			if len(backData) < 2 || validBitsOut != 0 {
				return nil, 0, errors.New("We need at least the CRC_A value and all 8 bits of the last byte must be received")
			}

			if crc, err := r.PCD_CalculateCRC(backData[:len(backData)-2]); err != nil {
				return nil, 0, err
			} else {
				if bytes.Compare(crc, backData[len(backData)-2:]) != 0 {
					return nil, 0, errors.New("Verify CRC_A - do our own calculation and store the control in controlBuffer.")
				}
			}
		}
	}

	return
}

/**
 * Transmits REQA or WUPA commands.
 * Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.
 */
func (r *MFRC522) PICC_REQA_or_WUPA(command byte, /* The command to send - PICC_CMD_REQA or PICC_CMD_WUPA */
	bufferATQA []byte /*  The buffer to store the ATQA (Answer to request) in */) (err error) {

	if err = r.PCD_ClearRegisterBitMask(CollReg, 0x80); err != nil { // ValuesAfterColl=1 => Bits received after collision are cleared.
		return err
	}

	// For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]
	validBits := byte(7)

	bufferATQA, validBitsOut, err := r.PCD_TransceiveData([]byte{command}, validBits, 0, false, true)
	if err != nil {
		return err
	}

	if len(bufferATQA) != 2 || validBitsOut != 0 {
		return errors.New("ATQA must be exactly 16 bits.")
	}

	return nil

}

/**
 * Transmits a REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame.
 * Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.
 */
func (r *MFRC522) PICC_RequestA(bufferATQA []byte /* The buffer to store the ATQA (Answer to request) in */) error {
	return r.PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA)
}

/////////////////////////////////////////////////////////////////////////////////////
// Convenience functions - does not add extra functionality
/////////////////////////////////////////////////////////////////////////////////////
func (r *MFRC522) PICC_IsNewCardPresent() (bool, error) {
	bufferATQA := make([]byte, 2)
	if err := r.PICC_RequestA(bufferATQA); err != nil {
		return false, err
	} else {
		return true, nil
	}

}
